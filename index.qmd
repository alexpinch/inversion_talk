---
title: "Modelling locally adaptive inversions"
author: Alex Pinch
date: 01/30/2023
format: 
  revealjs:
    standalone: true
    theme: [default, custom.scss]
    progress: true
incremental: false
highlight-style: a11y
---

## 

![](textbook_photo.png){width="200"}

## A short and sweet explanation of inversions

::: columns
::: {.column width="50%"}
-   Chromosomal inversions prevent recombination
-   How?
:::

::: {.column width="50%"}
![](inversion_graphic.png){width="400"}

Fig. 2, Kirkpatrick 2010 PLoS BIOLOGY
:::
:::

## Why how we code recombination is important

-   Preventing recombination is the sole driver for maintaining an inversion over generations (citation)

## How we code recombination

```{C}
//| echo: TRUE
//| eval: FALSE
//| code-line-numbers: "6-8|10-12|14-18|13-11"
recombination() {
  
  // Search both chromosomes of an individual for the inversion marker mutation
	gm1 = genome1.containsMarkerMutation(m2, invStart);
	gm2 = genome2.containsMarkerMutation(m2, invStart);
	
	if (!(gm1 | gm2)) { // If neither chromosomes have the inversion...
		return F; // Keep breakpoints where they are, return false (recombination proceeds normally)
	}
	
	inInv = (breakpoints > invStart) & (breakpoints <= invEnd);  // Check if the breakpoints are inside or outside the inversion
	if (sum(inInv) % 2 == 0) { // Sum the breakpoints and divide to see if they are even
		return F; // If they are even, return false (recombination proceeds normally)
	}
	
	if (gm1 & gm2) { // If the homozygote is inverted...
		left = (breakpoints == invStart); // and if the breakpoints are equal to the start and end of the inversion
		right = (breakpoints == invEnd + 1);
		// Sort the breakpoints
		breakpoints = sort(c(breakpoints[!(left | right)], 
			c(invStart, invEnd + 1)[c(sum(left) == 0, sum(right) == 0)]));
		return T; // Recombination breakpoints have changed, return true (recombination is prevented)
	} else { // Otherwise, the heterozygote is inverted: need to resample to get an even number of breakpoints
		breakpoints = sim.chromosome.drawBreakpoints(individual);
	}
	
	return T;
}
```

## A sense of the scale

-   This recombination function is called for every individual, in every population, every generation
-   500 individuals \* 9 populations \* 100,000 generations = ...
-   Need a server

## October Results

```{r}
library(tidyverse)
data <- # Read october data.csv
ggplot(data) +
  geom_point(mapping = aes(x = displ, y = hwy, color = class))
```
