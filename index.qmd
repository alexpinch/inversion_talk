---
title: ""
author: Alex Pinch
date: 01/30/2023
format: 
  revealjs:
    standalone: true
    theme: [default, custom.scss]
    progress: true
incremental: false
highlight-style: a11y
---

## Modelling locally adaptive inversions

```{css, echo=FALSE}
  .reveal h2 {
  font-size: 55px;
  position: bottom;
}
```

![Alex Pinch, Jan. 30 2023](title_slide.jpg){width="100%"}

## Stopping recombination

![Fig. 2, Kirkpatrick 2010](kirkpatrick_2010.png){width="50%"}

-   When offspring are heterozygous for an inversion, recombination does not occur as a broken segment cannot find their homologous pair

::: notes
A simplified diagram of what's happening during recombination. During recombination, chromosomal rearrangements like deletions can occur, but whole sections can also get flipped around. But, inversions are special. It's not like an insertion or deletion where the number of genes changes, and they aren't always super deleterious, they stick around! There's lots of interesting implications from the broader perspective of evolution. How they persist in populations is a bit puzzling, and they are suspected to drive speciation, and come to control important phenotypes like in Heliconious butterflies.
:::

## Why are inversions important?

-   15-20 years ago, found that inversions are way more prevalent than previously thought (Kirkpatrick, 2010)
-   They can persist through populations and homozygotes can accumulate more deleterious mutations over time (Huang, 2022)
-   Still puzzling how they stick around
-   If genetic information is almost identical (only linear order changed), how do they spread?

::: notes
Strutevant described the first inversions 100 years ago, and inferenced that this would stop recombination in heterozygotes but not homozygotes. Next generation sequencing allowed the discovery of tons more structural rearrangements, which has generated more interest.It's posed an interesting question in evolution: if it has almost the same genetic information as it's not-inverted counterpart, how can it spread through a population? And we know that some inversion heterozygotes have a lower mutation load, like the work that Greg has done in sunflowers
:::

## Local adaptation theory

-   Inversions can show geographical variation (Krimbas and Powell, 1992)
-   This implies that they might be locally adaptive
-   If an inversion traps genes that become ecologically favoured, this could explain why they persist

::: notes
:::

## Our idea

-   Individuals with a locally advantageous inversion will have an increase in mutational load, to the point where the advantage is lost

::: notes
By making a program that introduces an inversion, preventing recombination and giving inversion-carrying individuals a range of fitness benefits depending on which population they are from, we can make it output key data like fitness values, number of deleterious mutations and its inversion genotype. Others have modeled the long-term fate of inversions, and there's lots of ways of going about this. I'll try and point out where things could or have been changed.
:::

## How inversions spread

![Fig. 1, Faria et al. 2019 (Modified)](faria_2019.jpg){width="50%"}

::: notes
A simplified outline for the different outcomes of an inversion
:::

## How inversions spread

![Fig. 1, Faria et al., 2019 (Modified)](faria_2019_2.jpg){width="50%"}

::: notes
In this case, locally advantageous alleles causes some population divergence, but when does the mutational load increase tip this balance?
:::

## How we're testing it

-   By making a model that introduces a locally adaptive inversion across several populations we can keep track of fitness, number of mutations per genotype
-   Can run the model as many times as we want to find trends


## A SLiMtroduction

-   We built a forward-genetics simulation using SLiM
-   SLiM (**S**election on **Li**nked **M**utations) was developed by Ben Haller and Phillip Messer at Cornell
-   SLiM provides a basic framework for modelling individuals over generations
-   Computes at the gene level, not concerned with base pairs
-   Uses a proprietary programming language similar to R, but as fast as C

## A SLiMtroduction

![Haller, 2016](slim_functions.png){width="30%"}

::: notes
SLiM is one big loop, I'm pointing out the recombination function here because that's a pretty critical part for us and our model
:::

## Our model

::: columns
::: {.column width="60%"}
-   At time = 0
    -   Define a grid of subpopulations and establish a fitness gradient for inversion-carrying individuals
-   After 50,000 generations:
    -   Define a start and end point variable for the inversion
    -   Give one individual two copies of a mutation at that start position, will serve as a marker
:::

::: {.column width="40%"}
![](populations.jpg){width="100%"}
:::
:::

## Our model

-   Every generation:
    -   Check every individual for that marker mutation
    -   If found: suppress recombination and manually alter fitness
    -   Individuals have a chance to migrate to another subpopulation, where their inversion will either help or hurt them

## Our model

-   What this model is not doing:
    -   It is not actually inverting a section of a simulated chromosome
    -   Instead, we define the length and place a marker to keep track of it, changing the breakpoints and fitness manually
    -   It is not keeping track of base pairs, codons, amino acids, proteins...

## Altering recombination

-   Preventing recombination is at the base of how inversions are physically maintained on the chromosome over time, this is the crux of the model
-   In heterozygotes, recombination must be prevented
-   In homozygotes, the breakpoints must be changed and told where the inversion is

## Altering recombination

-   SLiM does recombination automatically, so you must define a function named 'recombination' to supersede it
-   If this function returns false, SLiM's normal recombinaton function takes over
-   If this function returns true, SLiM considers recombination over and continues the loop

## Altering recombination

![](flowchart.jpeg){width="70%"}

## Altering recombination

```{R}
#| echo: TRUE
#| eval: FALSE
#| code-line-numbers: "2-4|5-8|9-10|11-14|15-18|19-24|25-31"
recombination() {
  # Search both chromosomes of an individual for the inversion
	gm1 = genome1.containsMarkerMutation(m2, invStart);
	gm2 = genome2.containsMarkerMutation(m2, invStart);
	# If neither chromosomes have the inversion, return false
	if (!(gm1 | gm2)) { 
		return(F)
	}
	# Check if the breakpoints are outside the inversion
	inInv = (breakpoints > invStart) & (breakpoints <= invEnd);  
	# If their sum is even, return false
	if (sum(inInv) %% 2 == 0) { 
		return(F)
	}
	# If both chromosomes have the inversion (is homozygous)...
	if (gm1 & gm2) {
		left = (breakpoints == invStart); 
		right = (breakpoints == invEnd + 1);
		# Change the recombination breakpoints
		breakpoints = sort(c(breakpoints[!(left | right)], 
			c(invStart, invEnd + 1)[c(sum(left) == 0, sum(right) == 0)]));
		# Return true to make sure new breakpoints are preserved
		return(T) 
	} 
	# If none of the above, it is heterozygous
	else { 
	  # Draw new breakpoints and return true to preserve them
		breakpoints = sim.chromosome.drawBreakpoints(individual);
	}
	return(T)
}
```

## (Aside) A sense of scale

-   This recombination function is called for every individual, in every population, every generation
-   500 individuals \* 9 populations \* 100 000 generations \* 1000 iterations of this script = 450 billion times

## Previous work in modelling inversions in SLiM
-   Berdan et al. (2021) observed a sharp decrease in fitness when heterozygote was favoured
![Fig. 2A-B, Berdan 2021 (Adapted)](berdan_2021.jpg)

## Preliminary results

```{r}
library(tidyverse)
all_data <- tibble()
files <- length(list.files("/Users/alexpinch/GitHub/private/jan30_presentation/data_101822/full_runs/"))
full_runs <- list.files("/Users/alexpinch/GitHub/private/jan30_presentation/data_101822/full_runs/")
for (i in 1:files) {
  run <- (full_runs[i])
  typeof(run)
  setwd(file.path("/Users/alexpinch/GitHub/private/jan30_presentation/data_101822/full_runs//",run))
  run_data <- read.csv(file = paste(run,".csv",sep=""),skip=1,header=F) %>%
    rename(gen=V1,pop=V2,sample=V3,fitness=V4,inv_genotype=V5)
  run_data <- run_data %>% mutate(sim_run=run)
  all_data <- rbind(all_data, run_data)
}
all_data %>%
  mutate(fixed_fitness = case_when(inv_genotype == 2 & pop %in% c("pop1","pop2","pop4") ~ fitness - 0.1,
                                   inv_genotype == 2 & pop %in% c("pop6","pop8","pop9") ~ fitness + 0.1,
                                   inv_genotype == 1 & pop %in% c("pop1","pop2","pop4") ~ fitness - 0.05,
                                   inv_genotype == 1 & pop %in% c("pop6","pop8","pop9") ~ fitness + 0.05,
                                   TRUE ~ fitness)) %>%
  group_by(gen, pop, inv_genotype)%>%
  summarize(mean_fitness= mean(fixed_fitness,na.rm=T)) %>%
  ggplot(.,aes(x=gen,y=mean_fitness,group=inv_genotype,color=inv_genotype)) +
  geom_smooth(method="loess") +
  facet_wrap(~pop)
```

## Preliminary results

```{r}
library(tidyverse)
all_data <- tibble()
files <- length(list.files("/Users/alexpinch/GitHub/private/jan30_presentation/data_101822/full_runs/"))
full_runs <- list.files("/Users/alexpinch/GitHub/private/jan30_presentation/data_101822/full_runs/")
for (i in 1:files) {
  run <- (full_runs[i])
  typeof(run)
  setwd(file.path("/Users/alexpinch/GitHub/private/jan30_presentation/data_101822/full_runs//",run))
  run_data <- read.csv(file = paste(run,".csv",sep=""),skip=1,header=F) %>%
    rename(gen=V1,pop=V2,sample=V3,fitness=V4,inv_genotype=V5)
  run_data <- run_data %>% mutate(sim_run=run)
  all_data <- rbind(all_data, run_data)
}
genotype <- as_factor(inv_genotype)
all_data %>%
  group_by(gen,pop,inv_genotype) %>%
  summarize(n=n()) %>%
  mutate(freq = n / sum(n)) %>%
  ggplot(.,aes(x=gen,y=freq,color=genotype)) +
  geom_line() +
  facet_wrap(~pop)
```

## Preliminary results
```{r}
library(tidyverse)
all_data <- tibble()
files <- length(list.files("/Users/alexpinch/GitHub/private/jan30_presentation/data_101822/full_runs/"))
full_runs <- list.files("/Users/alexpinch/GitHub/private/jan30_presentation/data_101822/full_runs/")
for (i in 1:files) {
  run <- (full_runs[i])
  typeof(run)
  setwd(file.path("/Users/alexpinch/GitHub/private/jan30_presentation/data_101822/full_runs//",run))
  run_data <- read.csv(file = paste(run,".csv",sep=""),skip=1,header=F) %>%
    rename(gen=V1,pop=V2,sample=V3,fitness=V4,inv_genotype=V5)
  run_data <- run_data %>% mutate(sim_run=run)
  all_data <- rbind(all_data, run_data)
}
summarized_data <- all_data %>%
  mutate(fixed_fitness = case_when(inv_genotype == 2 & pop %in% c("pop1","pop2","pop4") ~ fitness - 0.1,
                                   inv_genotype == 2 & pop %in% c("pop6","pop8","pop9") ~ fitness + 0.1,
                                   inv_genotype == 1 & pop %in% c("pop1","pop2","pop4") ~ fitness - 0.05,
                                   inv_genotype == 1 & pop %in% c("pop6","pop8","pop9") ~ fitness + 0.05,
                                   TRUE ~ fitness)) %>%
  filter(!is.na(inv_genotype)) %>%
  group_by(gen, sim_run, inv_genotype) %>%
  summarize(mean_fit = mean(fixed_fitness,na.rm=T)) %>%
  group_by(gen,inv_genotype) %>%
  mutate(qnt_90 = quantile(mean_fit, 0.9),
         qnt_10 = quantile(mean_fit, 0.1),
         mean_sim_fit = quantile(mean_fit, 0.9)) ## 0.5 = median
summarized_data %>%
  ggplot(.) +
  geom_line(aes(x=gen,y=mean_sim_fit,group=inv_genotype,color=as.factor(inv_genotype))) +
  geom_ribbon(aes(x=gen,ymin=qnt_10,ymax=qnt_90,group=inv_genotype,fill=as.factor(inv_genotype)),alpha=0.2) # alpha = transparency

```

## (Aside) Parameter hell

::: columns
::: {.column width="60%"}
-   When modelling, the methods and results can be in constant flux
-   For every new idea, can go back, tweak the model, and generate new data
-   Avoid this mindset!! Hold strictly to the hypothesis... 
:::

::: {.column width="40%"}
![](parameters.png){width="100%"}
:::
:::

:: notes
This parameter issue being said, we probably do need to change the model
::

## Potential future results
![](example_graph_1.jpeg)

## Potential future results
![](example_graph_2.jpeg)
## Why were results unexpected?
-   Either we have scaled down the model incorrectly
-   Or something is wrong in our recombination model

## Thanks!
Questions?
